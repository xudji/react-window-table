{"version":3,"file":"ghostui.cjs.production.min.js","sources":["../src/ReadingProgress/core.ts","../src/ReadingProgress/useReadingProgress.ts","../src/utils/optimization/index.ts","../src/Scrollspy/type.ts","../src/Scrollspy/RootEl.ts","../src/Scrollspy/RootWindow.ts","../src/Scrollspy/RootFactory.ts","../src/Scrollspy/useScrollspy.ts","../src/Pagination/core.ts","../src/Pagination/usePagination.ts","../src/Pagination/index.tsx","../src/ReadingProgress/index.tsx","../src/Scrollspy/index.tsx"],"sourcesContent":["abstract class ReadingProgressCore {\n  abstract get rootSelector():\n    | (Window & typeof globalThis)\n    | HTMLElement\n    | null;\n\n  abstract getProgress: () => number;\n  abstract getViewportHeight: () => number;\n}\n\nclass ReadingProgressWindow extends ReadingProgressCore {\n  get rootSelector() {\n    return window;\n  }\n\n  private measureWrapperHeight = () => {\n    const targetElHeihgt = document.body.getBoundingClientRect().height || 0;\n\n    return Math.round(targetElHeihgt - this.getViewportHeight());\n  };\n\n  getViewportHeight = () => {\n    return Math.max(\n      document.documentElement.clientHeight,\n      window.innerHeight || 0\n    );\n  };\n\n  getProgress = () => {\n    const top = window.pageYOffset || document.documentElement.scrollTop;\n\n    return Math.round((top / this.measureWrapperHeight()) * 100);\n  };\n}\n\nclass ReadingProgressElement extends ReadingProgressCore {\n  rootEl: HTMLElement | null;\n  targetEl: HTMLElement | null;\n  constructor({ rootEl, targetEl }: { rootEl: string; targetEl: string }) {\n    super();\n    this.rootEl = document.querySelector(rootEl);\n    this.targetEl = document.querySelector(targetEl);\n  }\n\n  get rootSelector() {\n    return this.rootEl;\n  }\n\n  private measureWrapperHeight = () => {\n    const targetElHeight = this.targetEl?.getBoundingClientRect().height || 0;\n\n    return Math.round(targetElHeight - this.getViewportHeight());\n  };\n\n  getViewportHeight = () => {\n    return this.rootEl?.clientHeight || 0;\n  };\n\n  getProgress = () => {\n    const top = this.rootEl?.scrollTop || 0;\n\n    return Math.round((top / this.measureWrapperHeight()) * 100);\n  };\n}\n\nexport class ReadingProgress {\n  private rp: ReadingProgressCore;\n\n  constructor({ rootEl, targetEl }: { rootEl?: string; targetEl?: string }) {\n    this.rp =\n      typeof rootEl === 'string' && typeof targetEl === 'string'\n        ? new ReadingProgressElement({ rootEl, targetEl })\n        : new ReadingProgressWindow();\n  }\n\n  get rootSelector() {\n    return this.rp.rootSelector;\n  }\n\n  getViewportHeight = () => {\n    return this.rp.getViewportHeight();\n  };\n\n  getProgress = () => {\n    return this.rp.getProgress();\n  };\n}\n","import { useCallback, useEffect, useRef, useState } from 'react';\nimport { HookProps } from './type';\nimport { optimization } from '../utils';\nimport { ReadingProgress } from './core';\n\nexport const useReadingProgress = (props?: HookProps) => {\n  const rp = useRef<ReadingProgress>();\n\n  useEffect(() => {\n    rp.current = new ReadingProgress({\n      rootEl: props?.rootEl,\n      targetEl: props?.targetEl,\n    });\n  }, [props]);\n\n  const [value, updateProgressValue] = useState(rp.current?.getProgress() || 0);\n\n  const update = useCallback(() => {\n    updateProgressValue(rp.current?.getProgress() || 0);\n  }, []);\n  const debounceUpdate = useCallback(\n    optimization.debounce(() => {\n      update();\n    }),\n    []\n  );\n\n  useEffect(() => {\n    if (rp.current?.rootSelector) {\n      rp.current.rootSelector.addEventListener('scroll', debounceUpdate);\n    }\n    window.addEventListener('resize', debounceUpdate);\n    update();\n\n    return () => {\n      if (rp.current?.rootSelector) {\n        rp.current.rootSelector.removeEventListener('scroll', debounceUpdate);\n      }\n      window.removeEventListener('resize', debounceUpdate);\n    };\n  }, [update, debounceUpdate]);\n\n  return {\n    value,\n  };\n};\n","export const debounce = <F extends Function>(callback: F) => {\n  let reqID: number | null = null;\n\n  const exec = (args: F['arguments']) => () => {\n    // @ts-ignore TS2488\n    callback(...args);\n  };\n\n  return (...args: F['arguments']) => {\n    if (reqID) {\n      cancelAnimationFrame(reqID);\n    }\n    reqID = requestAnimationFrame(exec(args));\n  };\n};\n\nexport const throttle = <F extends Function>(callback: F) => {\n  let reqID: number | null = null;\n\n  const exec = (args: F['arguments']) => () => {\n    // @ts-ignore TS2488\n    callback(...args);\n    reqID = null;\n  };\n\n  return (...args: F['arguments']) => {\n    if (!reqID) {\n      reqID = requestAnimationFrame(exec(args));\n    }\n  };\n};\n","export abstract class Root {\n  abstract get outerHeight(): number;\n  abstract get scrollTop(): number;\n  abstract get scrollHeight(): number;\n  abstract isScrolledToBottom(): boolean;\n  abstract registerScrollEvent(callback: () => void): void;\n  abstract unregisterScrollEvent(callback: () => void): void;\n}\n","import { Root } from './type';\n\nexport class RootEl extends Root {\n  el: HTMLElement;\n\n  constructor(el: HTMLElement) {\n    super();\n    this.el = el;\n  }\n\n  get top() {\n    return this.el.getBoundingClientRect().top;\n  }\n\n  get outerHeight() {\n    return this.el.getBoundingClientRect().height;\n  }\n\n  get scrollTop() {\n    return this.el.scrollTop;\n  }\n\n  get scrollHeight() {\n    return this.el.scrollHeight;\n  }\n\n  isScrolledToBottom() {\n    return this.scrollTop + this.outerHeight >= this.scrollHeight;\n  }\n\n  registerScrollEvent(callback: () => void) {\n    this.el.addEventListener('scroll', callback);\n  }\n\n  unregisterScrollEvent(callback: () => void) {\n    this.el.removeEventListener('scroll', callback);\n  }\n\n  static create(selector: string) {\n    const el = document.querySelector(selector);\n\n    if (!el) {\n      throw new Error('element is not found.');\n    }\n    return new RootEl(el as HTMLElement);\n  }\n}\n","import { Root } from './type';\n\nexport class RootWindow extends Root {\n  get outerHeight() {\n    return window.innerHeight;\n  }\n\n  get scrollTop() {\n    return document.documentElement.scrollTop;\n  }\n\n  get scrollHeight() {\n    return document.documentElement.scrollHeight;\n  }\n\n  isScrolledToBottom() {\n    return this.scrollTop + this.outerHeight >= this.scrollHeight;\n  }\n\n  registerScrollEvent(callback: () => void) {\n    document.addEventListener('scroll', callback);\n  }\n\n  unregisterScrollEvent(callback: () => void) {\n    document.removeEventListener('scroll', callback);\n  }\n\n  static create() {\n    return new RootWindow();\n  }\n}\n","import { RootEl } from './RootEl';\nimport { RootWindow } from './RootWindow';\n\nexport class RootFactory {\n  static create(selector?: string): RootEl | RootWindow {\n    if (!selector) {\n      return RootWindow.create();\n    }\n    return RootEl.create(selector);\n  }\n}\n","import {\n  RefObject,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { RootEl } from './RootEl';\nimport { RootWindow } from './RootWindow';\nimport { RootFactory } from './RootFactory';\n\nexport const useScrollspy = ({\n  sectionRefs,\n  rootSelector,\n  offset = 0,\n}: {\n  sectionRefs: RefObject<Element>[];\n  rootSelector?: string;\n  offset?: number;\n}) => {\n  const rootEl = useRef<RootWindow | RootEl | null>(null);\n\n  useEffect(() => {\n    rootEl.current = RootFactory.create(rootSelector);\n  }, [rootSelector]);\n\n  const isScrolledToBottom = useCallback(() => {\n    if (!rootEl.current) {\n      return false;\n    }\n    return rootEl.current.isScrolledToBottom();\n  }, [rootEl]);\n\n  const isElementInViewport = useCallback(\n    (element: Element) => {\n      if (!rootEl.current) {\n        return false;\n      }\n      const innerScrollTop = rootEl.current.scrollTop;\n      const innerScrollBottom = innerScrollTop + rootEl.current.outerHeight;\n      const elementRect = element.getBoundingClientRect();\n      const elementScrollTop =\n        rootEl.current instanceof RootEl\n          ? innerScrollTop + elementRect.top - rootEl.current.top + offset\n          : innerScrollTop + elementRect.top + offset;\n      const elementScrollBottom = elementScrollTop + elementRect.height;\n\n      return [\n        elementScrollTop < innerScrollBottom,\n        elementScrollBottom > innerScrollTop,\n      ].every(v => v);\n    },\n    [rootEl, offset]\n  );\n\n  const getElementsStatusInViewport = useCallback(() => {\n    return sectionRefs.map(sectionRef => {\n      if (sectionRef.current) {\n        return isElementInViewport(sectionRef.current);\n      }\n      return false;\n    });\n  }, [isElementInViewport, sectionRefs]);\n\n  const [elementsStatusInViewport, updateElementsStatusInViewport] = useState<\n    boolean[]\n  >([]);\n\n  const currentElementIndexInViewport = useMemo(\n    () => elementsStatusInViewport.findIndex(status => status),\n    [elementsStatusInViewport]\n  );\n\n  const spy = useCallback(() => {\n    const newElementsStatusInViewport = isScrolledToBottom()\n      ? [...new Array(sectionRefs.length - 1).fill(false).map(v => v), true]\n      : getElementsStatusInViewport();\n    updateElementsStatusInViewport(newElementsStatusInViewport);\n  }, [getElementsStatusInViewport, isScrolledToBottom, sectionRefs]);\n\n  useEffect(() => {\n    spy();\n    if (rootEl.current) {\n      rootEl.current.registerScrollEvent(spy);\n    }\n\n    return () => {\n      if (rootEl.current) {\n        rootEl.current.unregisterScrollEvent(spy);\n      }\n    };\n  }, [spy]);\n\n  return {\n    elementsStatusInViewport,\n    currentElementIndexInViewport,\n  };\n};\n","export class Pagination {\n  private currentPage: number;\n  private totalPage: number;\n  private middlePagesSiblingCount: number;\n  private edgePageCount: number;\n\n  constructor({\n    currentPage,\n    totalPage,\n    middlePagesSiblingCount = 2,\n    edgePageCount = 2,\n  }: {\n    currentPage: number;\n    totalPage: number;\n    middlePagesSiblingCount?: number;\n    edgePageCount?: number;\n  }) {\n    this.currentPage = currentPage;\n    this.totalPage = totalPage;\n    this.middlePagesSiblingCount = middlePagesSiblingCount;\n    this.edgePageCount = edgePageCount;\n  }\n\n  private getAllPages = () => {\n    return [...Array(this.totalPage)].fill(1).map((_, i) => i + 1);\n  };\n\n  private getMiddlePageCount = () => {\n    return this.middlePagesSiblingCount * 2 + 1;\n  };\n\n  private isReachedToFirst = () =>\n    this.currentPage <= this.middlePagesSiblingCount;\n  private isReachedToLast = () =>\n    this.currentPage + this.middlePagesSiblingCount >= this.totalPage;\n\n  private getAllPreviousPages = () => {\n    return this.getAllPages().slice(0, this.getMiddlePages()[0] - 1);\n  };\n\n  private getAllNextPages = () => {\n    const totalPageItems = this.getAllPages();\n    const middlePages = this.getMiddlePages();\n\n    return totalPageItems.slice(\n      middlePages[middlePages.length - 1],\n      totalPageItems[totalPageItems.length]\n    );\n  };\n\n  hasPreviousPage = () => this.currentPage > 1;\n  hasNextPage = () => this.totalPage > this.currentPage;\n\n  getMiddlePages = () => {\n    const totalPageItems = this.getAllPages();\n    const middlePageCount = this.getMiddlePageCount();\n    if (this.isReachedToFirst()) {\n      return totalPageItems.slice(0, middlePageCount);\n    }\n    if (this.isReachedToLast()) {\n      return totalPageItems.slice(-middlePageCount);\n    }\n    return totalPageItems.slice(\n      this.currentPage - this.middlePagesSiblingCount - 1,\n      this.currentPage + this.middlePagesSiblingCount\n    );\n  };\n\n  getPreviousPages = () => {\n    if (this.isReachedToFirst()) {\n      return [];\n    }\n    if (this.getAllPreviousPages().length < 1) {\n      return [];\n    }\n    return this.getAllPages()\n      .slice(0, this.edgePageCount)\n      .filter(p => !this.getMiddlePages().includes(p));\n  };\n\n  getNextPages = () => {\n    if (this.isReachedToLast()) {\n      return [];\n    }\n    if (this.getAllNextPages().length < 1) {\n      return [];\n    }\n    const totalPages = this.getAllPages();\n    return totalPages\n      .slice(totalPages.length - this.edgePageCount, totalPages.length)\n      .filter(p => !this.getMiddlePages().includes(p));\n  };\n\n  isPreviousTruncable = () => {\n    return (\n      this.getAllPreviousPages().filter(\n        p =>\n          !this.getPreviousPages().includes(p) &&\n          !this.getMiddlePages().includes(p)\n      ).length > 0\n    );\n  };\n\n  isNextTruncable = () => {\n    return (\n      this.getAllNextPages().filter(\n        p =>\n          !this.getNextPages().includes(p) && !this.getMiddlePages().includes(p)\n      ).length > 0\n    );\n  };\n}\n","import { useMemo } from 'react';\nimport { Pagination } from './core';\nimport { UsePagination } from './types';\n\nconst MIDDLE_PAGES_SIBLING_COUNT = 2;\nconst EDGE_PAGE_COUNT = 2;\n\nexport const usePagination: UsePagination = ({\n  totalPage,\n  currentPage,\n  middlePagesSiblingCount = MIDDLE_PAGES_SIBLING_COUNT,\n  edgePageCount = EDGE_PAGE_COUNT,\n}) => {\n  const pagination = useMemo(\n    () =>\n      new Pagination({\n        totalPage,\n        currentPage,\n        middlePagesSiblingCount: middlePagesSiblingCount,\n        edgePageCount: edgePageCount,\n      }),\n    [totalPage, currentPage, middlePagesSiblingCount, edgePageCount]\n  );\n\n  return {\n    getMiddlePages: pagination.getMiddlePages,\n    hasPreviousPage: pagination.hasPreviousPage,\n    hasNextPage: pagination.hasNextPage,\n    getPreviousPages: pagination.getPreviousPages,\n    getNextPages: pagination.getNextPages,\n    isPreviousTruncable: pagination.isPreviousTruncable,\n    isNextTruncable: pagination.isNextTruncable,\n    totalPage,\n    currentPage,\n  };\n};\n","import { usePagination } from './usePagination';\nimport { UsePaginationProps } from './types';\n\ntype PaginationProps = {\n  children: (arg0: ReturnType<typeof usePagination>) => JSX.Element;\n} & UsePaginationProps;\n\nexport { usePagination };\n\nexport const Pagination = ({\n  children,\n  totalPage,\n  currentPage,\n  middlePagesSiblingCount,\n  edgePageCount,\n}: PaginationProps) => {\n  const pagination = usePagination({\n    totalPage,\n    currentPage,\n    middlePagesSiblingCount,\n    edgePageCount,\n  });\n\n  return children(pagination);\n};\n","import { ComponentProps } from './type';\nimport { useReadingProgress } from './useReadingProgress';\n\nexport { useReadingProgress };\n\nexport const ReadingProgress = ({\n  targetEl,\n  rootEl,\n  children,\n}: ComponentProps) => {\n  const readingProgress = useReadingProgress({\n    targetEl,\n    rootEl,\n  });\n\n  return children(readingProgress);\n};\n","import { RefObject } from 'react';\nimport { useScrollspy } from './useScrollspy';\n\nexport { useScrollspy };\n\nexport const Scrollspy = ({\n  children,\n  sectionRefs,\n  rootSelector,\n  offset,\n}: {\n  children: ({\n    elementsStatusInViewport,\n    currentElementIndexInViewport,\n  }: {\n    elementsStatusInViewport: boolean[];\n    currentElementIndexInViewport: number;\n  }) => JSX.Element;\n  sectionRefs: RefObject<Element>[];\n  rootSelector?: string;\n  offset?: number;\n}) => {\n  const {\n    elementsStatusInViewport,\n    currentElementIndexInViewport,\n  } = useScrollspy({\n    sectionRefs,\n    rootSelector,\n    offset,\n  });\n\n  return children({\n    elementsStatusInViewport,\n    currentElementIndexInViewport,\n  });\n};\n"],"names":["ReadingProgressCore","ReadingProgressWindow","targetElHeihgt","document","body","getBoundingClientRect","height","Math","round","_this","getViewportHeight","max","documentElement","clientHeight","window","innerHeight","top","pageYOffset","scrollTop","measureWrapperHeight","ReadingProgressElement","rootEl","targetEl","targetElHeight","_this2","querySelector","this","ReadingProgress","_this3","rp","getProgress","rootSelector","useReadingProgress","props","useRef","useEffect","current","callback","reqID","exec","useState","value","updateProgressValue","update","useCallback","debounceUpdate","args","cancelAnimationFrame","requestAnimationFrame","_rp$current3","addEventListener","_rp$current4","removeEventListener","Root","RootEl","el","isScrolledToBottom","outerHeight","scrollHeight","registerScrollEvent","unregisterScrollEvent","create","selector","Error","RootWindow","RootFactory","useScrollspy","sectionRefs","offset","isElementInViewport","element","innerScrollTop","innerScrollBottom","elementRect","elementScrollTop","every","v","getElementsStatusInViewport","map","sectionRef","elementsStatusInViewport","updateElementsStatusInViewport","currentElementIndexInViewport","useMemo","findIndex","status","spy","newElementsStatusInViewport","Array","length","fill","Pagination","currentPage","totalPage","middlePagesSiblingCount","edgePageCount","_","i","getAllPages","slice","getMiddlePages","totalPageItems","middlePages","middlePageCount","getMiddlePageCount","isReachedToFirst","isReachedToLast","getAllPreviousPages","filter","p","includes","getAllNextPages","totalPages","getPreviousPages","getNextPages","usePagination","pagination","hasPreviousPage","hasNextPage","isPreviousTruncable","isNextTruncable","children"],"mappings":"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"}