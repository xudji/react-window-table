import type AtomAssetsParser from "./assetParsers/atom";
import type { IParsedBlockAsset } from "./assetParsers/block";
import type { IDumiDemoProps } from "./client/theme-api/DumiDemo";
import type { ILocalesConfig, IThemeConfig } from "./client/theme-api/types";
import type { IContentTab } from "./features/tabs";
import type { IThemeLoadResult } from "./features/theme/loader";
import type { IModify } from '@umijs/core';
import type { AssetsPackage, ExampleBlockAsset } from 'dumi-assets-types';
import type { Element } from 'hast';
import type { defineConfig as defineUmiConfig, IApi as IUmiApi } from 'umi';
declare type Subset<K> = {
    [attr in keyof K]?: K[attr] extends Array<any> ? K[attr] : K[attr] extends object ? Subset<K[attr]> : K[attr] extends object | null ? Subset<K[attr]> | null : K[attr] extends object | null | undefined ? Subset<K[attr]> | null | undefined : K[attr];
};
declare type NoStringIndex<T> = {
    [K in keyof T as string extends K ? never : K]: T[K];
};
declare type IUmiConfig = Omit<NoStringIndex<Parameters<typeof defineUmiConfig>[0]>, 'resolve' | 'extraRemarkPlugins' | 'extraRehypePlugins' | 'themeConfig'>;
interface IDumiExtendsConfig {
    resolve: {
        docDirs: (string | {
            type?: string;
            dir: string;
        })[];
        /**
         * @deprecated use `resolve.atomDirs` instead
         */
        entityDirs?: {
            type: string;
            dir: string;
        }[];
        atomDirs: {
            type: string;
            dir: string;
        }[];
        codeBlockMode: 'active' | 'passive';
        entryFile?: string;
        forceKebabCaseRouting: boolean;
    };
    locales: ILocalesConfig;
    themeConfig: IThemeConfig;
    autoAlias?: boolean;
    /**
     * extra unified plugins
     */
    extraRemarkPlugins?: (string | Function | [string | Function, object])[];
    extraRehypePlugins?: (string | Function | [string | Function, object])[];
}
export declare type IDumiConfig = IUmiConfig & IDumiExtendsConfig;
export declare type IDumiUserConfig = Subset<Omit<IDumiConfig, 'locales'>> & {
    locales?: Exclude<IDumiConfig['locales'][0], {
        base: string;
    }>[] | Omit<Exclude<IDumiConfig['locales'][0], {
        suffix: string;
    }>, 'base'>[];
    [key: string]: any;
};
export declare abstract class IDumiTechStack {
    /**
     * tech stack name, such as 'react'
     */
    abstract name: string;
    /**
     * transform code
     */
    abstract isSupported(node: Element, lang: string): boolean;
    /**
     * transform for parse demo source to react component
     */
    abstract transformCode(raw: string, opts: {
        type: 'external' | 'code-block';
        fileAbsPath: string;
    }): string;
    /**
     * generator for return asset metadata
     */
    abstract generateMetadata?(asset: ExampleBlockAsset, opts: {
        type: Parameters<IDumiTechStack['transformCode']>[1]['type'];
        mdAbsPath: string;
        fileAbsPath?: string;
        entryPointCode?: string;
    }): Promise<ExampleBlockAsset> | ExampleBlockAsset;
    /**
     * generator for return previewer props
     */
    abstract generatePreviewerProps?(props: IDumiDemoProps['previewerProps'], opts: Parameters<NonNullable<IDumiTechStack['generateMetadata']>>[1]): Promise<IDumiDemoProps['previewerProps']> | IDumiDemoProps['previewerProps'];
    /**
     * generator for return file path of demo sources
     */
    abstract generateSources?(sources: IParsedBlockAsset['sources'], opts: Parameters<NonNullable<IDumiTechStack['generateMetadata']>>[1]): Promise<IParsedBlockAsset['sources']> | IParsedBlockAsset['sources'];
}
export declare type IApi = IUmiApi & {
    config: IDumiConfig & {
        [key: string]: any;
    };
    userConfig: IDumiUserConfig;
    service: IUmiApi['service'] & {
        themeData: IThemeLoadResult;
        atomParser: AtomAssetsParser;
    };
    /**
     * register a new tech stack
     */
    registerTechStack: (fn: () => IDumiTechStack) => void;
    /**
     * modify original theme data
     */
    modifyTheme: IModify<IThemeLoadResult, null>;
    /**
     * add content tab
     */
    addContentTab: (fn: () => IContentTab) => void;
    /**
     * modify assets metadata
     */
    modifyAssetsMetadata: IModify<AssetsPackage, null>;
    /**
     * get assets metadata
     */
    getAssetsMetadata?: () => Promise<AssetsPackage>;
};
export {};
